(* exerciser.dats -- Exercises the ward typed array library *)

#include "share/atspre_staload.hats"
staload "./../lib/memory.sats"
staload "./../lib/dom.sats"
staload "./../lib/promise.sats"
dynload "./../lib/memory.dats"
dynload "./../lib/dom.dats"
dynload "./../lib/promise.dats"
staload _ = "./../lib/memory.dats"
staload _ = "./../lib/dom.dats"
staload _ = "./../lib/promise.dats"

implement main0 () = let

  (* === Byte arrays: alloc, set, get, free === *)
  val () = println! ("=== Byte arrays: alloc, set, get, free ===")
  val arr = ward_arr_alloc<byte> (16)
  val () = ward_arr_set<byte> (arr, 0, int2byte0(42))
  val v = byte2int0(ward_arr_get<byte> (arr, 0))
  val () = println! ("arr[0] = ", v)
  val () = ward_arr_free<byte> (arr)
  val () = println! ("freed")

  (* === Byte arrays: split / join === *)
  val () = println! ("\n=== Byte arrays: split / join ===")
  val arr = ward_arr_alloc<byte> (40)
  val @(head, tail) = ward_arr_split<byte> (arr, 16)
  val () = println! ("split 40 into 16+24")
  val whole = ward_arr_join<byte> (head, tail)
  val () = ward_arr_free<byte> (whole)
  val () = println! ("rejoined and freed")

  (* === Byte arrays: freeze / thaw / borrow === *)
  val () = println! ("\n=== Byte arrays: freeze / thaw / borrow ===")
  val arr = ward_arr_alloc<byte> (16)
  val () = ward_arr_set<byte> (arr, 0, int2byte0(42))
  val @(frozen, borrow1) = ward_arr_freeze<byte> (arr)
  val v = byte2int0(ward_arr_read<byte> (borrow1, 0))
  val () = println! ("borrow read byte 0 = ", v)
  val borrow2 = ward_arr_dup<byte> (frozen, borrow1)
  val () = println! ("duped borrow (count now 2)")
  val @(b2a, b2b) = ward_arr_borrow_split<byte> (frozen, borrow2, 8)
  val va = byte2int0(ward_arr_read<byte> (b2a, 0))
  val () = println! ("split borrow, read sub-borrow[0] = ", va, " (count now 3)")
  val borrow2 = ward_arr_borrow_join<byte> (frozen, b2a, b2b)
  val () = println! ("rejoined sub-borrows (count now 2)")
  val () = ward_arr_drop<byte> (frozen, borrow1)
  val () = ward_arr_drop<byte> (frozen, borrow2)
  val () = println! ("dropped both borrows (count now 0)")
  val arr = ward_arr_thaw<byte> (frozen)
  val () = ward_arr_free<byte> (arr)
  val () = println! ("thawed and freed")

  (* === Typed int arrays === *)
  val () = println! ("\n=== Typed int arrays ===")
  val arr = ward_arr_alloc<int> (10)
  val () = ward_arr_set<int> (arr, 5, 42)
  val v = ward_arr_get<int> (arr, 5)
  val () = println! ("arr[5] = ", v)
  val () = ward_arr_set<int> (arr, 0, 100)
  val () = ward_arr_set<int> (arr, 9, 999)
  val v0 = ward_arr_get<int> (arr, 0)
  val v9 = ward_arr_get<int> (arr, 9)
  val () = println! ("arr[0] = ", v0, ", arr[9] = ", v9)

  (* === Typed int arrays: freeze / thaw === *)
  val () = println! ("\n=== Typed int arrays: freeze / thaw ===")
  val @(frozen, borrow1) = ward_arr_freeze<int> (arr)
  val v = ward_arr_read<int> (borrow1, 5)
  val () = println! ("borrowed read arr[5] = ", v)
  val borrow2 = ward_arr_dup<int> (frozen, borrow1)
  val () = println! ("duped typed borrow (count now 2)")
  val v1 = ward_arr_read<int> (borrow1, 0)
  val v2 = ward_arr_read<int> (borrow2, 9)
  val () = println! ("borrow1[0] = ", v1, ", borrow2[9] = ", v2)
  val () = ward_arr_drop<int> (frozen, borrow1)
  val () = ward_arr_drop<int> (frozen, borrow2)
  val () = println! ("dropped both borrows (count now 0)")
  val arr2 = ward_arr_thaw<int> (frozen)
  val () = ward_arr_set<int> (arr2, 5, 99)
  val v = ward_arr_get<int> (arr2, 5)
  val () = println! ("after thaw, arr[5] = ", v, " (was 42, now 99)")

  val () = ward_arr_free<int> (arr2)
  val () = println! ("freed")

  (* === Safe text: build, putc, done, get === *)
  val () = println! ("\n=== Safe text: compile-time character verification ===")
  val b = ward_text_build(5)
  val b = ward_text_putc(b, 0, char2int1('c'))
  val b = ward_text_putc(b, 1, char2int1('l'))
  val b = ward_text_putc(b, 2, char2int1('a'))
  val b = ward_text_putc(b, 3, char2int1('s'))
  val b = ward_text_putc(b, 4, char2int1('s'))
  val attr_class = ward_text_done(b)
  val v0 = byte2int0(ward_safe_text_get(attr_class, 0))
  val v4 = byte2int0(ward_safe_text_get(attr_class, 4))
  val () = println! ("safe_text[0] = ", v0, " ('c'=99)")
  val () = println! ("safe_text[4] = ", v4, " ('s'=115)")

  (* === DOM: stream create element, set attr, set text, remove children === *)
  val () = println! ("\n=== DOM: ward_dom stream operations ===")
  val dom = ward_dom_init()
  val () = println! ("dom state initialized")

  (* Build tag name "div" as safe text *)
  val b = ward_text_build(3)
  val b = ward_text_putc(b, 0, char2int1('d'))
  val b = ward_text_putc(b, 1, char2int1('i'))
  val b = ward_text_putc(b, 2, char2int1('v'))
  val tag_div = ward_text_done(b)

  val s = ward_dom_stream_begin(dom)
  val s = ward_dom_stream_create_element(s, 1, 0, tag_div, 3)
  val () = println! ("created element 'div' (node 1, parent 0)")

  (* Set attribute: name="class" (safe text), value from borrow *)
  val b = ward_text_build(5)
  val b = ward_text_putc(b, 0, char2int1('c'))
  val b = ward_text_putc(b, 1, char2int1('l'))
  val b = ward_text_putc(b, 2, char2int1('a'))
  val b = ward_text_putc(b, 3, char2int1('s'))
  val b = ward_text_putc(b, 4, char2int1('s'))
  val attr_class = ward_text_done(b)

  val vbuf = ward_arr_alloc<byte> (4)
  val () = ward_arr_set<byte> (vbuf, 0, int2byte0(109))  (* m *)
  val () = ward_arr_set<byte> (vbuf, 1, int2byte0(97))   (* a *)
  val () = ward_arr_set<byte> (vbuf, 2, int2byte0(105))  (* i *)
  val () = ward_arr_set<byte> (vbuf, 3, int2byte0(110))  (* n *)
  val @(vfrozen, vborrow) = ward_arr_freeze<byte> (vbuf)
  val s = ward_dom_stream_set_attr(s, 1, attr_class, 5, vborrow, 4)
  val () = println! ("set attr class='main' on node 1")
  val () = ward_arr_drop<byte> (vfrozen, vborrow)
  val vbuf = ward_arr_thaw<byte> (vfrozen)
  val () = ward_arr_free<byte> (vbuf)

  (* Set text from borrow *)
  val tbuf = ward_arr_alloc<byte> (5)
  val () = ward_arr_set<byte> (tbuf, 0, int2byte0(72))   (* H *)
  val () = ward_arr_set<byte> (tbuf, 1, int2byte0(101))  (* e *)
  val () = ward_arr_set<byte> (tbuf, 2, int2byte0(108))  (* l *)
  val () = ward_arr_set<byte> (tbuf, 3, int2byte0(108))  (* l *)
  val () = ward_arr_set<byte> (tbuf, 4, int2byte0(111))  (* o *)
  val @(tfrozen, tborrow) = ward_arr_freeze<byte> (tbuf)
  val s = ward_dom_stream_set_text(s, 1, tborrow, 5)
  val () = println! ("set text 'Hello' on node 1")

  (* Set style (dedicated setter) *)
  val s = ward_dom_stream_set_style(s, 1, tborrow, 5)
  val () = println! ("set style on node 1 via dedicated setter")

  val () = ward_arr_drop<byte> (tfrozen, tborrow)
  val tbuf = ward_arr_thaw<byte> (tfrozen)
  val () = ward_arr_free<byte> (tbuf)

  val s = ward_dom_stream_remove_children(s, 1)
  val () = println! ("removed children of node 1")

  val s = ward_dom_stream_remove_child(s, 1)
  val () = println! ("removed child node 1")

  val dom = ward_dom_stream_end(s)
  val () = ward_dom_fini(dom)
  val () = println! ("dom state freed")

  (* === ward_text_from_bytes: valid case === *)
  val () = println! ("\n=== ward_text_from_bytes: valid case ===")
  val vbuf = ward_arr_alloc<byte>(3)
  val () = ward_arr_set<byte>(vbuf, 0, int2byte0(97))  (* a *)
  val () = ward_arr_set<byte>(vbuf, 1, int2byte0(98))  (* b *)
  val () = ward_arr_set<byte>(vbuf, 2, int2byte0(99))  (* c *)
  val @(vfr, vbr) = ward_arr_freeze<byte>(vbuf)
  val res = ward_text_from_bytes(vbr, 3)
  val () = (case+ res of
    | ~ward_text_ok(t) => println! ("ward_text_from_bytes ok: got safe text")
    | ~ward_text_fail() => println! ("ERROR: expected ok"))
  val () = ward_arr_drop<byte>(vfr, vbr)
  val vbuf2 = ward_arr_thaw<byte>(vfr)
  val () = ward_arr_free<byte>(vbuf2)

  (* === ward_text_from_bytes: invalid case === *)
  val () = println! ("\n=== ward_text_from_bytes: invalid case ===")
  val ibuf = ward_arr_alloc<byte>(2)
  val () = ward_arr_set<byte>(ibuf, 0, int2byte0(60))  (* < *)
  val () = ward_arr_set<byte>(ibuf, 1, int2byte0(97))  (* a *)
  val @(ifr, ibr) = ward_arr_freeze<byte>(ibuf)
  val res2 = ward_text_from_bytes(ibr, 2)
  val () = (case+ res2 of
    | ~ward_text_ok(_t) => println! ("ERROR: expected fail")
    | ~ward_text_fail() => println! ("ward_text_from_bytes fail: correctly rejected"))
  val () = ward_arr_drop<byte>(ifr, ibr)
  val ibuf2 = ward_arr_thaw<byte>(ifr)
  val () = ward_arr_free<byte>(ibuf2)

  (* === Alloc/free across size classes (exercises free-list recycling) === *)
  val () = println! ("\n=== Alloc/free across size classes ===")

  (* Bucket 0: 32 bytes — small byte array *)
  val a1 = ward_arr_alloc<byte>(8)
  val () = ward_arr_set<byte>(a1, 0, int2byte0(11))
  val () = ward_arr_free<byte>(a1)
  val () = println! ("  8-byte alloc+free (bucket 32)")

  (* Bucket 1: 128 bytes — medium byte array *)
  val a2 = ward_arr_alloc<byte>(100)
  val () = ward_arr_set<byte>(a2, 99, int2byte0(22))
  val () = ward_arr_free<byte>(a2)
  val () = println! ("  100-byte alloc+free (bucket 128)")

  (* Bucket 2: 512 bytes — larger array *)
  val a3 = ward_arr_alloc<byte>(256)
  val () = ward_arr_set<byte>(a3, 255, int2byte0(33))
  val () = ward_arr_free<byte>(a3)
  val () = println! ("  256-byte alloc+free (bucket 512)")

  (* Bucket 3: 4096 bytes — page-sized *)
  val a4 = ward_arr_alloc<byte>(2048)
  val () = ward_arr_set<byte>(a4, 2047, int2byte0(44))
  val () = ward_arr_free<byte>(a4)
  val () = println! ("  2048-byte alloc+free (bucket 4096)")

  (* Re-allocate same sizes — should recycle from free lists *)
  val b1 = ward_arr_alloc<byte>(8)
  val v = byte2int0(ward_arr_get<byte>(b1, 0))
  val () = assertloc(v = 0) (* must be zeroed *)
  val () = println! ("  recycled 8-byte: zeroed ok")

  val b2 = ward_arr_alloc<byte>(100)
  val v = byte2int0(ward_arr_get<byte>(b2, 99))
  val () = assertloc(v = 0)
  val () = println! ("  recycled 100-byte: zeroed ok")

  val b3 = ward_arr_alloc<byte>(256)
  val v = byte2int0(ward_arr_get<byte>(b3, 255))
  val () = assertloc(v = 0)
  val () = println! ("  recycled 256-byte: zeroed ok")

  val b4 = ward_arr_alloc<byte>(2048)
  val v = byte2int0(ward_arr_get<byte>(b4, 2047))
  val () = assertloc(v = 0)
  val () = println! ("  recycled 2048-byte: zeroed ok")

  val () = ward_arr_free<byte>(b1)
  val () = ward_arr_free<byte>(b2)
  val () = ward_arr_free<byte>(b3)
  val () = ward_arr_free<byte>(b4)

  (* Int arrays at various sizes — exercises sizeof(int) * n *)
  val c1 = ward_arr_alloc<int>(4)    (* 16 bytes -> bucket 32 *)
  val () = ward_arr_set<int>(c1, 3, 777)
  val v = ward_arr_get<int>(c1, 3)
  val () = assertloc(v = 777)
  val () = ward_arr_free<int>(c1)
  val () = println! ("  int[4] alloc+set+free (bucket 32)")

  val c2 = ward_arr_alloc<int>(30)   (* 120 bytes -> bucket 128 *)
  val () = ward_arr_set<int>(c2, 29, 888)
  val v = ward_arr_get<int>(c2, 29)
  val () = assertloc(v = 888)
  val () = ward_arr_free<int>(c2)
  val () = println! ("  int[30] alloc+set+free (bucket 128)")

  val c3 = ward_arr_alloc<int>(100)  (* 400 bytes -> bucket 512 *)
  val () = ward_arr_set<int>(c3, 99, 999)
  val v = ward_arr_get<int>(c3, 99)
  val () = assertloc(v = 999)
  val () = ward_arr_free<int>(c3)
  val () = println! ("  int[100] alloc+set+free (bucket 512)")

  val c4 = ward_arr_alloc<int>(1000) (* 4000 bytes -> bucket 4096 *)
  val () = ward_arr_set<int>(c4, 999, 1111)
  val v = ward_arr_get<int>(c4, 999)
  val () = assertloc(v = 1111)
  val () = ward_arr_free<int>(c4)
  val () = println! ("  int[1000] alloc+set+free (bucket 4096)")

  val () = println! ("all size classes exercised")

  (* === Promises: pre-resolved + extract === *)
  val () = println! ("\n=== Promises: pre-resolved + extract ===")
  val p = ward_promise_resolved<int> (42)
  val v = ward_promise_extract<int> (p)
  val () = println! ("pre-resolved = ", v)

  (* === Promises: create / resolve / discard === *)
  val () = println! ("\n=== Promises: create / resolve / discard ===")
  val @(p, r) = ward_promise_create<int> ()
  val () = ward_promise_resolve<int> (r, 99)
  val () = ward_promise_discard<int><Pending> (p)
  val () = println! ("resolved and discarded")

  val () = println! ("\n=== All operations exercised successfully ===")

in end

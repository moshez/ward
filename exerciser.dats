(* exerciser.dats -- Exercises all 6 layers of the ward memory library *)

#include "share/atspre_staload.hats"
staload "./memory.sats"
dynload "./memory.dats"
staload _ = "./memory.dats"

implement main0 () = let

  (* === Layer 1: sized_malloc / sized_free === *)
  val () = println! ("=== Layer 1: sized_malloc / sized_free ===")
  val raw = sized_malloc (40)
  val p = raw_ptr (raw)
  val () = print! ("allocated 40 bytes at ")
  val () = print_ptr (p)
  val () = print_newline ()
  val () = sized_free (raw)
  val () = println! ("freed successfully")

  (* === Layer 2: raw_advance / raw_rejoin === *)
  val () = println! ("\n=== Layer 2: raw_advance / raw_rejoin ===")
  val raw = sized_malloc (40)
  val @(head, tail) = raw_advance (raw, 16)
  val () = println! ("split 40 bytes into 16+24")
  val whole = raw_rejoin (head, tail)
  val () = sized_free (whole)
  val () = println! ("rejoined and freed")

  (* === Layer 3: safe_memset / safe_memcpy === *)
  val () = println! ("\n=== Layer 3: safe_memset / safe_memcpy ===")
  val src = sized_malloc (16)
  val dst = sized_malloc (16)
  val srcp = raw_ptr (src)
  val dstp = raw_ptr (dst)
  val () = safe_memset (src, srcp, 170, 16)
  val () = println! ("memset 16 bytes to 0xAA")
  val () = safe_memcpy (dst, src, dstp, srcp, 16)
  val () = println! ("memcpy 16 bytes src -> dst")
  val () = sized_free (src)
  val () = sized_free (dst)
  val () = println! ("freed src and dst")

  (* === Layer 4: raw_freeze / raw_thaw === *)
  val () = println! ("\n=== Layer 4: raw_freeze / raw_thaw ===")
  val raw = sized_malloc (16)
  val rp = raw_ptr (raw)
  val () = safe_memset (raw, rp, 42, 1)
  val @(frozen, borrow1) = raw_freeze (raw)
  val bp = raw_borrow_ptr (borrow1)
  val v = raw_borrow_read (borrow1, bp, 0)
  val () = println! ("borrow read byte 0 = ", v)
  val borrow2 = raw_borrow_clone (frozen, borrow1)
  val () = println! ("cloned borrow (count now 2)")
  val () = raw_borrow_return (frozen, borrow1)
  val () = raw_borrow_return (frozen, borrow2)
  val () = println! ("returned both borrows (count now 0)")
  val raw = raw_thaw (frozen)
  val () = sized_free (raw)
  val () = println! ("thawed and freed")

  (* === Layer 5: tptr (typed arrays) === *)
  val () = println! ("\n=== Layer 5: tptr (typed arrays) ===")
  val raw = sized_malloc (40)
  val rp = raw_ptr (raw)
  val tp = tptr_init<int> (raw, rp, 10)
  val tpp = tptr_ptr<int> (tp)
  val () = tptr_set<int> (tp, tpp, 5, 42)
  val v = tptr_get<int> (tp, tpp, 5)
  val () = println! ("tp[5] = ", v)
  val () = tptr_set<int> (tp, tpp, 0, 100)
  val () = tptr_set<int> (tp, tpp, 9, 999)
  val v0 = tptr_get<int> (tp, tpp, 0)
  val v9 = tptr_get<int> (tp, tpp, 9)
  val () = println! ("tp[0] = ", v0, ", tp[9] = ", v9)

  (* === Layer 6: tptr_freeze / tptr_thaw === *)
  val () = println! ("\n=== Layer 6: tptr_freeze / tptr_thaw ===")
  val @(frozen, borrow1) = tptr_freeze<int> (tp)
  val bp = tptr_borrow_getptr<int> (borrow1)
  val v = tptr_borrow_get<int> (borrow1, bp, 5)
  val () = println! ("borrowed read tp[5] = ", v)
  val borrow2 = tptr_borrow_clone<int> (frozen, borrow1)
  val () = println! ("cloned typed borrow (count now 2)")
  val bp2 = tptr_borrow_getptr<int> (borrow2)
  val v1 = tptr_borrow_get<int> (borrow1, bp, 0)
  val v2 = tptr_borrow_get<int> (borrow2, bp2, 9)
  val () = println! ("borrow1[0] = ", v1, ", borrow2[9] = ", v2)
  val () = tptr_borrow_return<int> (frozen, borrow1)
  val () = tptr_borrow_return<int> (frozen, borrow2)
  val () = println! ("returned both borrows (count now 0)")
  val tp2 = tptr_thaw<int> (frozen)
  val tpp2 = tptr_ptr<int> (tp2)
  val () = tptr_set<int> (tp2, tpp2, 5, 99)
  val v = tptr_get<int> (tp2, tpp2, 5)
  val () = println! ("after thaw, tp[5] = ", v, " (was 42, now 99)")

  (* Clean up: dissolve typed->raw, then free *)
  val raw_back = tptr_dissolve<int> (tp2)
  val () = sized_free (raw_back)
  val () = println! ("dissolved and freed")

  val () = println! ("\n=== All layers exercised successfully ===")

in end

(* exerciser.dats -- Exercises all 6 layers of the ward memory library *)

#include "share/atspre_staload.hats"
staload "./memory.sats"
dynload "./memory.dats"
staload _ = "./memory.dats"

implement main0 () = let

  (* === Layer 1: ward_malloc / ward_free === *)
  val () = println! ("=== Layer 1: ward_malloc / ward_free ===")
  val own = ward_malloc (40)
  val () = println! ("allocated 40 bytes")
  val () = ward_free (own)
  val () = println! ("freed successfully")

  (* === Layer 2: ward_split / ward_join === *)
  val () = println! ("\n=== Layer 2: ward_split / ward_join ===")
  val own = ward_malloc (40)
  val @(head, tail) = ward_split (own, 16)
  val () = println! ("split 40 bytes into 16+24")
  val whole = ward_join (head, tail)
  val () = ward_free (whole)
  val () = println! ("rejoined and freed")

  (* === Layer 3: ward_memset / ward_memcpy === *)
  val () = println! ("\n=== Layer 3: ward_memset / ward_memcpy ===")
  val src = ward_malloc (16)
  val dst = ward_malloc (16)
  val () = ward_memset (src, 170, 16)
  val () = println! ("memset 16 bytes to 0xAA")
  val () = ward_memcpy (dst, src, 16)
  val () = println! ("memcpy 16 bytes src -> dst")
  val () = ward_free (src)
  val () = ward_free (dst)
  val () = println! ("freed src and dst")

  (* === Layer 4: ward_freeze / ward_thaw === *)
  val () = println! ("\n=== Layer 4: ward_freeze / ward_thaw ===")
  val own = ward_malloc (16)
  val () = ward_memset (own, 42, 1)
  val @(frozen, borrow1) = ward_freeze (own)
  val v = ward_read (borrow1, 0)
  val () = println! ("borrow read byte 0 = ", v)
  val borrow2 = ward_dup (frozen, borrow1)
  val () = println! ("duped borrow (count now 2)")
  val () = ward_drop (frozen, borrow1)
  val () = ward_drop (frozen, borrow2)
  val () = println! ("dropped both borrows (count now 0)")
  val own = ward_thaw (frozen)
  val () = ward_free (own)
  val () = println! ("thawed and freed")

  (* === Layer 5: ward_arr (typed arrays) === *)
  val () = println! ("\n=== Layer 5: ward_arr (typed arrays) ===")
  val own = ward_malloc (40)
  val arr = ward_arr_init<int> (own, 10)
  val () = ward_arr_set<int> (arr, 5, 42)
  val v = ward_arr_get<int> (arr, 5)
  val () = println! ("arr[5] = ", v)
  val () = ward_arr_set<int> (arr, 0, 100)
  val () = ward_arr_set<int> (arr, 9, 999)
  val v0 = ward_arr_get<int> (arr, 0)
  val v9 = ward_arr_get<int> (arr, 9)
  val () = println! ("arr[0] = ", v0, ", arr[9] = ", v9)

  (* === Layer 6: ward_arr_freeze / ward_arr_thaw === *)
  val () = println! ("\n=== Layer 6: ward_arr_freeze / ward_arr_thaw ===")
  val @(frozen, borrow1) = ward_arr_freeze<int> (arr)
  val v = ward_arr_read<int> (borrow1, 5)
  val () = println! ("borrowed read arr[5] = ", v)
  val borrow2 = ward_arr_dup<int> (frozen, borrow1)
  val () = println! ("duped typed borrow (count now 2)")
  val v1 = ward_arr_read<int> (borrow1, 0)
  val v2 = ward_arr_read<int> (borrow2, 9)
  val () = println! ("borrow1[0] = ", v1, ", borrow2[9] = ", v2)
  val () = ward_arr_drop<int> (frozen, borrow1)
  val () = ward_arr_drop<int> (frozen, borrow2)
  val () = println! ("dropped both borrows (count now 0)")
  val arr2 = ward_arr_thaw<int> (frozen)
  val () = ward_arr_set<int> (arr2, 5, 99)
  val v = ward_arr_get<int> (arr2, 5)
  val () = println! ("after thaw, arr[5] = ", v, " (was 42, now 99)")

  (* Clean up: fini typed->raw, then free *)
  val own_back = ward_arr_fini<int> (arr2)
  val () = ward_free (own_back)
  val () = println! ("finalized and freed")

  val () = println! ("\n=== All layers exercised successfully ===")

in end

(* exerciser.dats -- Exercises all 6 layers of the ward memory library *)

#include "share/atspre_staload.hats"
staload "./memory.sats"
dynload "./memory.dats"
staload _ = "./memory.dats"

implement main0 () = let

  (* === Layer 1: ward_malloc / ward_free === *)
  val () = println! ("=== Layer 1: ward_malloc / ward_free ===")
  val own = ward_malloc (40)
  val () = println! ("allocated 40 bytes")
  val () = ward_free (own)
  val () = println! ("freed successfully")

  (* === Layer 2: ward_split / ward_join === *)
  val () = println! ("\n=== Layer 2: ward_split / ward_join ===")
  val own = ward_malloc (40)
  val @(head, tail) = ward_split (own, 16)
  val () = println! ("split 40 bytes into 16+24")
  val whole = ward_join (head, tail)
  val () = ward_free (whole)
  val () = println! ("rejoined and freed")

  (* === Layer 3: ward_memset / ward_memcpy / ward_peek / ward_poke === *)
  val () = println! ("\n=== Layer 3: ward_memset / ward_memcpy ===")
  val src = ward_malloc (16)
  val dst = ward_malloc (16)
  val () = ward_memset (src, 170, 16)
  val () = println! ("memset 16 bytes to 0xAA")
  (* memcpy source must be a borrow â€” freeze, copy, drop, thaw *)
  val @(src_frozen, src_borrow) = ward_freeze (src)
  val () = ward_memcpy (dst, src_borrow, 16)
  val () = ward_drop (src_frozen, src_borrow)
  val src = ward_thaw (src_frozen)
  val () = println! ("memcpy 16 bytes src -> dst")
  (* peek/poke: single-byte access (consume/return ownership) *)
  val dst = ward_poke (dst, 0, 99)
  val @(v, dst) = ward_peek (dst, 0)
  val () = println! ("poke dst[0]=99, peek dst[0] = ", v)
  val () = ward_free (src)
  val () = ward_free (dst)
  val () = println! ("freed src and dst")

  (* === Layer 4: ward_freeze / ward_thaw === *)
  val () = println! ("\n=== Layer 4: ward_freeze / ward_thaw ===")
  val own = ward_malloc (16)
  val () = ward_memset (own, 42, 1)
  val @(frozen, borrow1) = ward_freeze (own)
  val v = ward_read (borrow1, 0)
  val () = println! ("borrow read byte 0 = ", v)
  val borrow2 = ward_dup (frozen, borrow1)
  val () = println! ("duped borrow (count now 2)")
  (* borrow_split: split borrow2 into two sub-borrows (count 2->3) *)
  val @(b2a, b2b) = ward_borrow_split (frozen, borrow2, 8)
  val va = ward_read (b2a, 0)
  val () = println! ("split borrow, read sub-borrow[0] = ", va, " (count now 3)")
  (* borrow_join: rejoin sub-borrows (count 3->2) *)
  val borrow2 = ward_borrow_join (frozen, b2a, b2b)
  val () = println! ("rejoined sub-borrows (count now 2)")
  val () = ward_drop (frozen, borrow1)
  val () = ward_drop (frozen, borrow2)
  val () = println! ("dropped both borrows (count now 0)")
  val own = ward_thaw (frozen)
  val () = ward_free (own)
  val () = println! ("thawed and freed")

  (* === Layer 5: ward_arr (typed arrays) === *)
  val () = println! ("\n=== Layer 5: ward_arr (typed arrays) ===")
  val arr = ward_arr_alloc<int> (10)
  val () = ward_arr_set<int> (arr, 5, 42)
  val v = ward_arr_get<int> (arr, 5)
  val () = println! ("arr[5] = ", v)
  val () = ward_arr_set<int> (arr, 0, 100)
  val () = ward_arr_set<int> (arr, 9, 999)
  val v0 = ward_arr_get<int> (arr, 0)
  val v9 = ward_arr_get<int> (arr, 9)
  val () = println! ("arr[0] = ", v0, ", arr[9] = ", v9)

  (* === Layer 6: ward_arr_freeze / ward_arr_thaw === *)
  val () = println! ("\n=== Layer 6: ward_arr_freeze / ward_arr_thaw ===")
  val @(frozen, borrow1) = ward_arr_freeze<int> (arr)
  val v = ward_arr_read<int> (borrow1, 5)
  val () = println! ("borrowed read arr[5] = ", v)
  val borrow2 = ward_arr_dup<int> (frozen, borrow1)
  val () = println! ("duped typed borrow (count now 2)")
  val v1 = ward_arr_read<int> (borrow1, 0)
  val v2 = ward_arr_read<int> (borrow2, 9)
  val () = println! ("borrow1[0] = ", v1, ", borrow2[9] = ", v2)
  val () = ward_arr_drop<int> (frozen, borrow1)
  val () = ward_arr_drop<int> (frozen, borrow2)
  val () = println! ("dropped both borrows (count now 0)")
  val arr2 = ward_arr_thaw<int> (frozen)
  val () = ward_arr_set<int> (arr2, 5, 99)
  val v = ward_arr_get<int> (arr2, 5)
  val () = println! ("after thaw, arr[5] = ", v, " (was 42, now 99)")

  (* Clean up: free directly (paired with ward_arr_alloc) *)
  val () = ward_arr_free<int> (arr2)
  val () = println! ("freed")

  val () = println! ("\n=== All layers exercised successfully ===")

in end
